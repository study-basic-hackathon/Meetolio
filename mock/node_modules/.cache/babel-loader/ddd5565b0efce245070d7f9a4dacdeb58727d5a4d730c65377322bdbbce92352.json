{"ast":null,"code":"import { Util } from '../Util.js';\nimport { Factory } from '../Factory.js';\nimport { Shape } from '../Shape.js';\nimport { Path } from './Path.js';\nimport { Text, stringToArray } from './Text.js';\nimport { getNumberValidator } from '../Validators.js';\nimport { _registerNode } from '../Global.js';\nvar EMPTY_STRING = '',\n  NORMAL = 'normal';\nfunction _fillFunc(context) {\n  context.fillText(this.partialText, 0, 0);\n}\nfunction _strokeFunc(context) {\n  context.strokeText(this.partialText, 0, 0);\n}\nexport class TextPath extends Shape {\n  constructor(config) {\n    super(config);\n    this.dummyCanvas = Util.createCanvasElement();\n    this.dataArray = [];\n    this.dataArray = Path.parsePathData(this.attrs.data);\n    this.on('dataChange.konva', function () {\n      this.dataArray = Path.parsePathData(this.attrs.data);\n      this._setTextData();\n    });\n    this.on('textChange.konva alignChange.konva letterSpacingChange.konva kerningFuncChange.konva fontSizeChange.konva fontFamilyChange.konva', this._setTextData);\n    this._setTextData();\n  }\n  _sceneFunc(context) {\n    context.setAttr('font', this._getContextFont());\n    context.setAttr('textBaseline', this.textBaseline());\n    context.setAttr('textAlign', 'left');\n    context.save();\n    var textDecoration = this.textDecoration();\n    var fill = this.fill();\n    var fontSize = this.fontSize();\n    var glyphInfo = this.glyphInfo;\n    if (textDecoration === 'underline') {\n      context.beginPath();\n    }\n    for (var i = 0; i < glyphInfo.length; i++) {\n      context.save();\n      var p0 = glyphInfo[i].p0;\n      context.translate(p0.x, p0.y);\n      context.rotate(glyphInfo[i].rotation);\n      this.partialText = glyphInfo[i].text;\n      context.fillStrokeShape(this);\n      if (textDecoration === 'underline') {\n        if (i === 0) {\n          context.moveTo(0, fontSize / 2 + 1);\n        }\n        context.lineTo(fontSize, fontSize / 2 + 1);\n      }\n      context.restore();\n    }\n    if (textDecoration === 'underline') {\n      context.strokeStyle = fill;\n      context.lineWidth = fontSize / 20;\n      context.stroke();\n    }\n    context.restore();\n  }\n  _hitFunc(context) {\n    context.beginPath();\n    var glyphInfo = this.glyphInfo;\n    if (glyphInfo.length >= 1) {\n      var p0 = glyphInfo[0].p0;\n      context.moveTo(p0.x, p0.y);\n    }\n    for (var i = 0; i < glyphInfo.length; i++) {\n      var p1 = glyphInfo[i].p1;\n      context.lineTo(p1.x, p1.y);\n    }\n    context.setAttr('lineWidth', this.fontSize());\n    context.setAttr('strokeStyle', this.colorKey);\n    context.stroke();\n  }\n  getTextWidth() {\n    return this.textWidth;\n  }\n  getTextHeight() {\n    Util.warn('text.getTextHeight() method is deprecated. Use text.height() - for full height and text.fontSize() - for one line height.');\n    return this.textHeight;\n  }\n  setText(text) {\n    return Text.prototype.setText.call(this, text);\n  }\n  _getContextFont() {\n    return Text.prototype._getContextFont.call(this);\n  }\n  _getTextSize(text) {\n    var dummyCanvas = this.dummyCanvas;\n    var _context = dummyCanvas.getContext('2d');\n    _context.save();\n    _context.font = this._getContextFont();\n    var metrics = _context.measureText(text);\n    _context.restore();\n    return {\n      width: metrics.width,\n      height: parseInt(this.attrs.fontSize, 10)\n    };\n  }\n  _setTextData() {\n    var that = this;\n    var size = this._getTextSize(this.attrs.text);\n    var letterSpacing = this.letterSpacing();\n    var align = this.align();\n    var kerningFunc = this.kerningFunc();\n    this.textWidth = size.width;\n    this.textHeight = size.height;\n    var textFullWidth = Math.max(this.textWidth + ((this.attrs.text || '').length - 1) * letterSpacing, 0);\n    this.glyphInfo = [];\n    var fullPathWidth = 0;\n    for (var l = 0; l < that.dataArray.length; l++) {\n      if (that.dataArray[l].pathLength > 0) {\n        fullPathWidth += that.dataArray[l].pathLength;\n      }\n    }\n    var offset = 0;\n    if (align === 'center') {\n      offset = Math.max(0, fullPathWidth / 2 - textFullWidth / 2);\n    }\n    if (align === 'right') {\n      offset = Math.max(0, fullPathWidth - textFullWidth);\n    }\n    var charArr = stringToArray(this.text());\n    var spacesNumber = this.text().split(' ').length - 1;\n    var p0, p1, pathCmd;\n    var pIndex = -1;\n    var currentT = 0;\n    var getNextPathSegment = function () {\n      currentT = 0;\n      var pathData = that.dataArray;\n      for (var j = pIndex + 1; j < pathData.length; j++) {\n        if (pathData[j].pathLength > 0) {\n          pIndex = j;\n          return pathData[j];\n        } else if (pathData[j].command === 'M') {\n          p0 = {\n            x: pathData[j].points[0],\n            y: pathData[j].points[1]\n          };\n        }\n      }\n      return {};\n    };\n    var findSegmentToFitCharacter = function (c) {\n      var glyphWidth = that._getTextSize(c).width + letterSpacing;\n      if (c === ' ' && align === 'justify') {\n        glyphWidth += (fullPathWidth - textFullWidth) / spacesNumber;\n      }\n      var currLen = 0;\n      var attempts = 0;\n      p1 = undefined;\n      while (Math.abs(glyphWidth - currLen) / glyphWidth > 0.01 && attempts < 20) {\n        attempts++;\n        var cumulativePathLength = currLen;\n        while (pathCmd === undefined) {\n          pathCmd = getNextPathSegment();\n          if (pathCmd && cumulativePathLength + pathCmd.pathLength < glyphWidth) {\n            cumulativePathLength += pathCmd.pathLength;\n            pathCmd = undefined;\n          }\n        }\n        if (Object.keys(pathCmd).length === 0 || p0 === undefined) {\n          return undefined;\n        }\n        var needNewSegment = false;\n        switch (pathCmd.command) {\n          case 'L':\n            if (Path.getLineLength(p0.x, p0.y, pathCmd.points[0], pathCmd.points[1]) > glyphWidth) {\n              p1 = Path.getPointOnLine(glyphWidth, p0.x, p0.y, pathCmd.points[0], pathCmd.points[1], p0.x, p0.y);\n            } else {\n              pathCmd = undefined;\n            }\n            break;\n          case 'A':\n            var start = pathCmd.points[4];\n            var dTheta = pathCmd.points[5];\n            var end = pathCmd.points[4] + dTheta;\n            if (currentT === 0) {\n              currentT = start + 0.00000001;\n            } else if (glyphWidth > currLen) {\n              currentT += Math.PI / 180.0 * dTheta / Math.abs(dTheta);\n            } else {\n              currentT -= Math.PI / 360.0 * dTheta / Math.abs(dTheta);\n            }\n            if (dTheta < 0 && currentT < end || dTheta >= 0 && currentT > end) {\n              currentT = end;\n              needNewSegment = true;\n            }\n            p1 = Path.getPointOnEllipticalArc(pathCmd.points[0], pathCmd.points[1], pathCmd.points[2], pathCmd.points[3], currentT, pathCmd.points[6]);\n            break;\n          case 'C':\n            if (currentT === 0) {\n              if (glyphWidth > pathCmd.pathLength) {\n                currentT = 0.00000001;\n              } else {\n                currentT = glyphWidth / pathCmd.pathLength;\n              }\n            } else if (glyphWidth > currLen) {\n              currentT += (glyphWidth - currLen) / pathCmd.pathLength / 2;\n            } else {\n              currentT = Math.max(currentT - (currLen - glyphWidth) / pathCmd.pathLength / 2, 0);\n            }\n            if (currentT > 1.0) {\n              currentT = 1.0;\n              needNewSegment = true;\n            }\n            p1 = Path.getPointOnCubicBezier(currentT, pathCmd.start.x, pathCmd.start.y, pathCmd.points[0], pathCmd.points[1], pathCmd.points[2], pathCmd.points[3], pathCmd.points[4], pathCmd.points[5]);\n            break;\n          case 'Q':\n            if (currentT === 0) {\n              currentT = glyphWidth / pathCmd.pathLength;\n            } else if (glyphWidth > currLen) {\n              currentT += (glyphWidth - currLen) / pathCmd.pathLength;\n            } else {\n              currentT -= (currLen - glyphWidth) / pathCmd.pathLength;\n            }\n            if (currentT > 1.0) {\n              currentT = 1.0;\n              needNewSegment = true;\n            }\n            p1 = Path.getPointOnQuadraticBezier(currentT, pathCmd.start.x, pathCmd.start.y, pathCmd.points[0], pathCmd.points[1], pathCmd.points[2], pathCmd.points[3]);\n            break;\n        }\n        if (p1 !== undefined) {\n          currLen = Path.getLineLength(p0.x, p0.y, p1.x, p1.y);\n        }\n        if (needNewSegment) {\n          needNewSegment = false;\n          pathCmd = undefined;\n        }\n      }\n    };\n    var testChar = 'C';\n    var glyphWidth = that._getTextSize(testChar).width + letterSpacing;\n    var lettersInOffset = offset / glyphWidth - 1;\n    for (var k = 0; k < lettersInOffset; k++) {\n      findSegmentToFitCharacter(testChar);\n      if (p0 === undefined || p1 === undefined) {\n        break;\n      }\n      p0 = p1;\n    }\n    for (var i = 0; i < charArr.length; i++) {\n      findSegmentToFitCharacter(charArr[i]);\n      if (p0 === undefined || p1 === undefined) {\n        break;\n      }\n      var width = Path.getLineLength(p0.x, p0.y, p1.x, p1.y);\n      var kern = 0;\n      if (kerningFunc) {\n        try {\n          kern = kerningFunc(charArr[i - 1], charArr[i]) * this.fontSize();\n        } catch (e) {\n          kern = 0;\n        }\n      }\n      p0.x += kern;\n      p1.x += kern;\n      this.textWidth += kern;\n      var midpoint = Path.getPointOnLine(kern + width / 2.0, p0.x, p0.y, p1.x, p1.y);\n      var rotation = Math.atan2(p1.y - p0.y, p1.x - p0.x);\n      this.glyphInfo.push({\n        transposeX: midpoint.x,\n        transposeY: midpoint.y,\n        text: charArr[i],\n        rotation: rotation,\n        p0: p0,\n        p1: p1\n      });\n      p0 = p1;\n    }\n  }\n  getSelfRect() {\n    if (!this.glyphInfo.length) {\n      return {\n        x: 0,\n        y: 0,\n        width: 0,\n        height: 0\n      };\n    }\n    var points = [];\n    this.glyphInfo.forEach(function (info) {\n      points.push(info.p0.x);\n      points.push(info.p0.y);\n      points.push(info.p1.x);\n      points.push(info.p1.y);\n    });\n    var minX = points[0] || 0;\n    var maxX = points[0] || 0;\n    var minY = points[1] || 0;\n    var maxY = points[1] || 0;\n    var x, y;\n    for (var i = 0; i < points.length / 2; i++) {\n      x = points[i * 2];\n      y = points[i * 2 + 1];\n      minX = Math.min(minX, x);\n      maxX = Math.max(maxX, x);\n      minY = Math.min(minY, y);\n      maxY = Math.max(maxY, y);\n    }\n    var fontSize = this.fontSize();\n    return {\n      x: minX - fontSize / 2,\n      y: minY - fontSize / 2,\n      width: maxX - minX + fontSize,\n      height: maxY - minY + fontSize\n    };\n  }\n  destroy() {\n    Util.releaseCanvas(this.dummyCanvas);\n    return super.destroy();\n  }\n}\nTextPath.prototype._fillFunc = _fillFunc;\nTextPath.prototype._strokeFunc = _strokeFunc;\nTextPath.prototype._fillFuncHit = _fillFunc;\nTextPath.prototype._strokeFuncHit = _strokeFunc;\nTextPath.prototype.className = 'TextPath';\nTextPath.prototype._attrsAffectingSize = ['text', 'fontSize', 'data'];\n_registerNode(TextPath);\nFactory.addGetterSetter(TextPath, 'data');\nFactory.addGetterSetter(TextPath, 'fontFamily', 'Arial');\nFactory.addGetterSetter(TextPath, 'fontSize', 12, getNumberValidator());\nFactory.addGetterSetter(TextPath, 'fontStyle', NORMAL);\nFactory.addGetterSetter(TextPath, 'align', 'left');\nFactory.addGetterSetter(TextPath, 'letterSpacing', 0, getNumberValidator());\nFactory.addGetterSetter(TextPath, 'textBaseline', 'middle');\nFactory.addGetterSetter(TextPath, 'fontVariant', NORMAL);\nFactory.addGetterSetter(TextPath, 'text', EMPTY_STRING);\nFactory.addGetterSetter(TextPath, 'textDecoration', null);\nFactory.addGetterSetter(TextPath, 'kerningFunc', null);","map":{"version":3,"names":["Util","Factory","Shape","Path","Text","stringToArray","getNumberValidator","_registerNode","EMPTY_STRING","NORMAL","_fillFunc","context","fillText","partialText","_strokeFunc","strokeText","TextPath","constructor","config","dummyCanvas","createCanvasElement","dataArray","parsePathData","attrs","data","on","_setTextData","_sceneFunc","setAttr","_getContextFont","textBaseline","save","textDecoration","fill","fontSize","glyphInfo","beginPath","i","length","p0","translate","x","y","rotate","rotation","text","fillStrokeShape","moveTo","lineTo","restore","strokeStyle","lineWidth","stroke","_hitFunc","p1","colorKey","getTextWidth","textWidth","getTextHeight","warn","textHeight","setText","prototype","call","_getTextSize","_context","getContext","font","metrics","measureText","width","height","parseInt","that","size","letterSpacing","align","kerningFunc","textFullWidth","Math","max","fullPathWidth","l","pathLength","offset","charArr","spacesNumber","split","pathCmd","pIndex","currentT","getNextPathSegment","pathData","j","command","points","findSegmentToFitCharacter","c","glyphWidth","currLen","attempts","undefined","abs","cumulativePathLength","Object","keys","needNewSegment","getLineLength","getPointOnLine","start","dTheta","end","PI","getPointOnEllipticalArc","getPointOnCubicBezier","getPointOnQuadraticBezier","testChar","lettersInOffset","k","kern","e","midpoint","atan2","push","transposeX","transposeY","getSelfRect","forEach","info","minX","maxX","minY","maxY","min","destroy","releaseCanvas","_fillFuncHit","_strokeFuncHit","className","_attrsAffectingSize","addGetterSetter"],"sources":["/Users/takahiro/Dev/webhack/node_modules/konva/lib/shapes/TextPath.js"],"sourcesContent":["import { Util } from '../Util.js';\nimport { Factory } from '../Factory.js';\nimport { Shape } from '../Shape.js';\nimport { Path } from './Path.js';\nimport { Text, stringToArray } from './Text.js';\nimport { getNumberValidator } from '../Validators.js';\nimport { _registerNode } from '../Global.js';\nvar EMPTY_STRING = '', NORMAL = 'normal';\nfunction _fillFunc(context) {\n    context.fillText(this.partialText, 0, 0);\n}\nfunction _strokeFunc(context) {\n    context.strokeText(this.partialText, 0, 0);\n}\nexport class TextPath extends Shape {\n    constructor(config) {\n        super(config);\n        this.dummyCanvas = Util.createCanvasElement();\n        this.dataArray = [];\n        this.dataArray = Path.parsePathData(this.attrs.data);\n        this.on('dataChange.konva', function () {\n            this.dataArray = Path.parsePathData(this.attrs.data);\n            this._setTextData();\n        });\n        this.on('textChange.konva alignChange.konva letterSpacingChange.konva kerningFuncChange.konva fontSizeChange.konva fontFamilyChange.konva', this._setTextData);\n        this._setTextData();\n    }\n    _sceneFunc(context) {\n        context.setAttr('font', this._getContextFont());\n        context.setAttr('textBaseline', this.textBaseline());\n        context.setAttr('textAlign', 'left');\n        context.save();\n        var textDecoration = this.textDecoration();\n        var fill = this.fill();\n        var fontSize = this.fontSize();\n        var glyphInfo = this.glyphInfo;\n        if (textDecoration === 'underline') {\n            context.beginPath();\n        }\n        for (var i = 0; i < glyphInfo.length; i++) {\n            context.save();\n            var p0 = glyphInfo[i].p0;\n            context.translate(p0.x, p0.y);\n            context.rotate(glyphInfo[i].rotation);\n            this.partialText = glyphInfo[i].text;\n            context.fillStrokeShape(this);\n            if (textDecoration === 'underline') {\n                if (i === 0) {\n                    context.moveTo(0, fontSize / 2 + 1);\n                }\n                context.lineTo(fontSize, fontSize / 2 + 1);\n            }\n            context.restore();\n        }\n        if (textDecoration === 'underline') {\n            context.strokeStyle = fill;\n            context.lineWidth = fontSize / 20;\n            context.stroke();\n        }\n        context.restore();\n    }\n    _hitFunc(context) {\n        context.beginPath();\n        var glyphInfo = this.glyphInfo;\n        if (glyphInfo.length >= 1) {\n            var p0 = glyphInfo[0].p0;\n            context.moveTo(p0.x, p0.y);\n        }\n        for (var i = 0; i < glyphInfo.length; i++) {\n            var p1 = glyphInfo[i].p1;\n            context.lineTo(p1.x, p1.y);\n        }\n        context.setAttr('lineWidth', this.fontSize());\n        context.setAttr('strokeStyle', this.colorKey);\n        context.stroke();\n    }\n    getTextWidth() {\n        return this.textWidth;\n    }\n    getTextHeight() {\n        Util.warn('text.getTextHeight() method is deprecated. Use text.height() - for full height and text.fontSize() - for one line height.');\n        return this.textHeight;\n    }\n    setText(text) {\n        return Text.prototype.setText.call(this, text);\n    }\n    _getContextFont() {\n        return Text.prototype._getContextFont.call(this);\n    }\n    _getTextSize(text) {\n        var dummyCanvas = this.dummyCanvas;\n        var _context = dummyCanvas.getContext('2d');\n        _context.save();\n        _context.font = this._getContextFont();\n        var metrics = _context.measureText(text);\n        _context.restore();\n        return {\n            width: metrics.width,\n            height: parseInt(this.attrs.fontSize, 10),\n        };\n    }\n    _setTextData() {\n        var that = this;\n        var size = this._getTextSize(this.attrs.text);\n        var letterSpacing = this.letterSpacing();\n        var align = this.align();\n        var kerningFunc = this.kerningFunc();\n        this.textWidth = size.width;\n        this.textHeight = size.height;\n        var textFullWidth = Math.max(this.textWidth + ((this.attrs.text || '').length - 1) * letterSpacing, 0);\n        this.glyphInfo = [];\n        var fullPathWidth = 0;\n        for (var l = 0; l < that.dataArray.length; l++) {\n            if (that.dataArray[l].pathLength > 0) {\n                fullPathWidth += that.dataArray[l].pathLength;\n            }\n        }\n        var offset = 0;\n        if (align === 'center') {\n            offset = Math.max(0, fullPathWidth / 2 - textFullWidth / 2);\n        }\n        if (align === 'right') {\n            offset = Math.max(0, fullPathWidth - textFullWidth);\n        }\n        var charArr = stringToArray(this.text());\n        var spacesNumber = this.text().split(' ').length - 1;\n        var p0, p1, pathCmd;\n        var pIndex = -1;\n        var currentT = 0;\n        var getNextPathSegment = function () {\n            currentT = 0;\n            var pathData = that.dataArray;\n            for (var j = pIndex + 1; j < pathData.length; j++) {\n                if (pathData[j].pathLength > 0) {\n                    pIndex = j;\n                    return pathData[j];\n                }\n                else if (pathData[j].command === 'M') {\n                    p0 = {\n                        x: pathData[j].points[0],\n                        y: pathData[j].points[1],\n                    };\n                }\n            }\n            return {};\n        };\n        var findSegmentToFitCharacter = function (c) {\n            var glyphWidth = that._getTextSize(c).width + letterSpacing;\n            if (c === ' ' && align === 'justify') {\n                glyphWidth += (fullPathWidth - textFullWidth) / spacesNumber;\n            }\n            var currLen = 0;\n            var attempts = 0;\n            p1 = undefined;\n            while (Math.abs(glyphWidth - currLen) / glyphWidth > 0.01 &&\n                attempts < 20) {\n                attempts++;\n                var cumulativePathLength = currLen;\n                while (pathCmd === undefined) {\n                    pathCmd = getNextPathSegment();\n                    if (pathCmd &&\n                        cumulativePathLength + pathCmd.pathLength < glyphWidth) {\n                        cumulativePathLength += pathCmd.pathLength;\n                        pathCmd = undefined;\n                    }\n                }\n                if (Object.keys(pathCmd).length === 0 || p0 === undefined) {\n                    return undefined;\n                }\n                var needNewSegment = false;\n                switch (pathCmd.command) {\n                    case 'L':\n                        if (Path.getLineLength(p0.x, p0.y, pathCmd.points[0], pathCmd.points[1]) > glyphWidth) {\n                            p1 = Path.getPointOnLine(glyphWidth, p0.x, p0.y, pathCmd.points[0], pathCmd.points[1], p0.x, p0.y);\n                        }\n                        else {\n                            pathCmd = undefined;\n                        }\n                        break;\n                    case 'A':\n                        var start = pathCmd.points[4];\n                        var dTheta = pathCmd.points[5];\n                        var end = pathCmd.points[4] + dTheta;\n                        if (currentT === 0) {\n                            currentT = start + 0.00000001;\n                        }\n                        else if (glyphWidth > currLen) {\n                            currentT += ((Math.PI / 180.0) * dTheta) / Math.abs(dTheta);\n                        }\n                        else {\n                            currentT -= ((Math.PI / 360.0) * dTheta) / Math.abs(dTheta);\n                        }\n                        if ((dTheta < 0 && currentT < end) ||\n                            (dTheta >= 0 && currentT > end)) {\n                            currentT = end;\n                            needNewSegment = true;\n                        }\n                        p1 = Path.getPointOnEllipticalArc(pathCmd.points[0], pathCmd.points[1], pathCmd.points[2], pathCmd.points[3], currentT, pathCmd.points[6]);\n                        break;\n                    case 'C':\n                        if (currentT === 0) {\n                            if (glyphWidth > pathCmd.pathLength) {\n                                currentT = 0.00000001;\n                            }\n                            else {\n                                currentT = glyphWidth / pathCmd.pathLength;\n                            }\n                        }\n                        else if (glyphWidth > currLen) {\n                            currentT += (glyphWidth - currLen) / pathCmd.pathLength / 2;\n                        }\n                        else {\n                            currentT = Math.max(currentT - (currLen - glyphWidth) / pathCmd.pathLength / 2, 0);\n                        }\n                        if (currentT > 1.0) {\n                            currentT = 1.0;\n                            needNewSegment = true;\n                        }\n                        p1 = Path.getPointOnCubicBezier(currentT, pathCmd.start.x, pathCmd.start.y, pathCmd.points[0], pathCmd.points[1], pathCmd.points[2], pathCmd.points[3], pathCmd.points[4], pathCmd.points[5]);\n                        break;\n                    case 'Q':\n                        if (currentT === 0) {\n                            currentT = glyphWidth / pathCmd.pathLength;\n                        }\n                        else if (glyphWidth > currLen) {\n                            currentT += (glyphWidth - currLen) / pathCmd.pathLength;\n                        }\n                        else {\n                            currentT -= (currLen - glyphWidth) / pathCmd.pathLength;\n                        }\n                        if (currentT > 1.0) {\n                            currentT = 1.0;\n                            needNewSegment = true;\n                        }\n                        p1 = Path.getPointOnQuadraticBezier(currentT, pathCmd.start.x, pathCmd.start.y, pathCmd.points[0], pathCmd.points[1], pathCmd.points[2], pathCmd.points[3]);\n                        break;\n                }\n                if (p1 !== undefined) {\n                    currLen = Path.getLineLength(p0.x, p0.y, p1.x, p1.y);\n                }\n                if (needNewSegment) {\n                    needNewSegment = false;\n                    pathCmd = undefined;\n                }\n            }\n        };\n        var testChar = 'C';\n        var glyphWidth = that._getTextSize(testChar).width + letterSpacing;\n        var lettersInOffset = offset / glyphWidth - 1;\n        for (var k = 0; k < lettersInOffset; k++) {\n            findSegmentToFitCharacter(testChar);\n            if (p0 === undefined || p1 === undefined) {\n                break;\n            }\n            p0 = p1;\n        }\n        for (var i = 0; i < charArr.length; i++) {\n            findSegmentToFitCharacter(charArr[i]);\n            if (p0 === undefined || p1 === undefined) {\n                break;\n            }\n            var width = Path.getLineLength(p0.x, p0.y, p1.x, p1.y);\n            var kern = 0;\n            if (kerningFunc) {\n                try {\n                    kern = kerningFunc(charArr[i - 1], charArr[i]) * this.fontSize();\n                }\n                catch (e) {\n                    kern = 0;\n                }\n            }\n            p0.x += kern;\n            p1.x += kern;\n            this.textWidth += kern;\n            var midpoint = Path.getPointOnLine(kern + width / 2.0, p0.x, p0.y, p1.x, p1.y);\n            var rotation = Math.atan2(p1.y - p0.y, p1.x - p0.x);\n            this.glyphInfo.push({\n                transposeX: midpoint.x,\n                transposeY: midpoint.y,\n                text: charArr[i],\n                rotation: rotation,\n                p0: p0,\n                p1: p1,\n            });\n            p0 = p1;\n        }\n    }\n    getSelfRect() {\n        if (!this.glyphInfo.length) {\n            return {\n                x: 0,\n                y: 0,\n                width: 0,\n                height: 0,\n            };\n        }\n        var points = [];\n        this.glyphInfo.forEach(function (info) {\n            points.push(info.p0.x);\n            points.push(info.p0.y);\n            points.push(info.p1.x);\n            points.push(info.p1.y);\n        });\n        var minX = points[0] || 0;\n        var maxX = points[0] || 0;\n        var minY = points[1] || 0;\n        var maxY = points[1] || 0;\n        var x, y;\n        for (var i = 0; i < points.length / 2; i++) {\n            x = points[i * 2];\n            y = points[i * 2 + 1];\n            minX = Math.min(minX, x);\n            maxX = Math.max(maxX, x);\n            minY = Math.min(minY, y);\n            maxY = Math.max(maxY, y);\n        }\n        var fontSize = this.fontSize();\n        return {\n            x: minX - fontSize / 2,\n            y: minY - fontSize / 2,\n            width: maxX - minX + fontSize,\n            height: maxY - minY + fontSize,\n        };\n    }\n    destroy() {\n        Util.releaseCanvas(this.dummyCanvas);\n        return super.destroy();\n    }\n}\nTextPath.prototype._fillFunc = _fillFunc;\nTextPath.prototype._strokeFunc = _strokeFunc;\nTextPath.prototype._fillFuncHit = _fillFunc;\nTextPath.prototype._strokeFuncHit = _strokeFunc;\nTextPath.prototype.className = 'TextPath';\nTextPath.prototype._attrsAffectingSize = ['text', 'fontSize', 'data'];\n_registerNode(TextPath);\nFactory.addGetterSetter(TextPath, 'data');\nFactory.addGetterSetter(TextPath, 'fontFamily', 'Arial');\nFactory.addGetterSetter(TextPath, 'fontSize', 12, getNumberValidator());\nFactory.addGetterSetter(TextPath, 'fontStyle', NORMAL);\nFactory.addGetterSetter(TextPath, 'align', 'left');\nFactory.addGetterSetter(TextPath, 'letterSpacing', 0, getNumberValidator());\nFactory.addGetterSetter(TextPath, 'textBaseline', 'middle');\nFactory.addGetterSetter(TextPath, 'fontVariant', NORMAL);\nFactory.addGetterSetter(TextPath, 'text', EMPTY_STRING);\nFactory.addGetterSetter(TextPath, 'textDecoration', null);\nFactory.addGetterSetter(TextPath, 'kerningFunc', null);\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}